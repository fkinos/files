#include <SDL2/SDL.h>
#include <stdio.h>
#include <dirent.h>
#include <limits.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

#define TITLE "FILES"
#define WIDTH 400
#define HEIGHT 300

#define BLACK 0x000000
#define WHITE 0xffffff
#define RED 0xff0000

static int zoom = 1;
static int reqdraw;

static SDL_Window *gWindow = NULL;
static SDL_Renderer *gRenderer = NULL;
static SDL_Texture *gTexture = NULL;
static unsigned int *pixels;

unsigned char font[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*   */
  0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00, /* ! */
  0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, /* " */
  0x66, 0x66, 0xff, 0x66, 0xff, 0x66, 0x66, 0x00, /* # */
  0x18, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x18, 0x00, /* $ */
  0x62, 0x66, 0x0c, 0x18, 0x30, 0x66, 0x46, 0x00, /* % */
  0x3c, 0x66, 0x3c, 0x38, 0x67, 0x66, 0x3f, 0x00, /* & */
  0x06, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, /* ' */
  0x0c, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00, /* ( */
  0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00, /* ) */
  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00, /* * */
  0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, /* + */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x00, /* , */
  0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, /* - */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, /* . */
  0x00, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00, /* / */
  0x3c, 0x66, 0x6e, 0x76, 0x66, 0x66, 0x3c, 0x00, /* 0 */
  0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7e, 0x00, /* 1 */
  0x3c, 0x66, 0x06, 0x0c, 0x30, 0x60, 0x7e, 0x00, /* 2 */
  0x3c, 0x66, 0x06, 0x1c, 0x06, 0x66, 0x3c, 0x00, /* 3 */
  0x06, 0x0e, 0x1e, 0x66, 0x7f, 0x06, 0x06, 0x00, /* 4 */
  0x7e, 0x60, 0x7c, 0x06, 0x06, 0x66, 0x3c, 0x00, /* 5 */
  0x3c, 0x66, 0x60, 0x7c, 0x66, 0x66, 0x3c, 0x00, /* 6 */
  0x7e, 0x66, 0x0c, 0x18, 0x18, 0x18, 0x18, 0x00, /* 7 */
  0x3c, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c, 0x00, /* 8 */
  0x3c, 0x66, 0x66, 0x3e, 0x06, 0x66, 0x3c, 0x00, /* 9 */
  0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, /* : */
  0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30, /* ; */
  0x0e, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0e, 0x00, /* < */
  0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00, /* = */
  0x70, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x70, 0x00, /* > */
  0x3c, 0x66, 0x06, 0x0c, 0x18, 0x00, 0x18, 0x00, /* ? */
  0x3c, 0x66, 0x6e, 0x6e, 0x60, 0x62, 0x3c, 0x00, /* @ */
  0x18, 0x3c, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00, /* A */
  0x7c, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x7c, 0x00, /* B */
  0x3c, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3c, 0x00, /* C */
  0x78, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0x78, 0x00, /* D */
  0x7e, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7e, 0x00, /* E */
  0x7e, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00, /* F */
  0x3c, 0x66, 0x60, 0x6e, 0x66, 0x66, 0x3c, 0x00, /* G */
  0x66, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00, /* H */
  0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, /* I */
  0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x6c, 0x38, 0x00, /* J */
  0x66, 0x6c, 0x78, 0x70, 0x78, 0x6c, 0x66, 0x00, /* K */
  0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7e, 0x00, /* L */
  0x63, 0x77, 0x7f, 0x6b, 0x63, 0x63, 0x63, 0x00, /* M */
  0x66, 0x76, 0x7e, 0x7e, 0x6e, 0x66, 0x66, 0x00, /* N */
  0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00, /* O */
  0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0x00, /* P */
  0x3c, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x0e, 0x00, /* Q */
  0x7c, 0x66, 0x66, 0x7c, 0x78, 0x6c, 0x66, 0x00, /* R */
  0x3c, 0x66, 0x60, 0x3c, 0x06, 0x66, 0x3c, 0x00, /* S */
  0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, /* T */
  0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00, /* U */
  0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00, /* V */
  0x63, 0x63, 0x63, 0x6b, 0x7f, 0x77, 0x63, 0x00, /* W */
  0x66, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x66, 0x00, /* X */
  0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x00, /* Y */
  0x7e, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x7e, 0x00, /* Z */
  0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00, /* [ */
  0x0c, 0x12, 0x30, 0x7c, 0x30, 0x62, 0xfc, 0x00, /* \ */
  0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00, /* [ */
  0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, /* ^ */
  0x00, 0x10, 0x30, 0x7f, 0x7f, 0x30, 0x10, 0x00, /* _ */
  0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, /* ` */
  0x00, 0x00, 0x3c, 0x06, 0x3e, 0x66, 0x3e, 0x00, /* a */
  0x00, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x7c, 0x00, /* b */
  0x00, 0x00, 0x3c, 0x60, 0x60, 0x60, 0x3c, 0x00, /* c */
  0x00, 0x06, 0x06, 0x3e, 0x66, 0x66, 0x3e, 0x00, /* d */
  0x00, 0x00, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00, /* e */
  0x00, 0x0e, 0x18, 0x3e, 0x18, 0x18, 0x18, 0x00, /* f */
  0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x7c, /* g */
  0x00, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x00, /* h */
  0x00, 0x18, 0x00, 0x38, 0x18, 0x18, 0x3c, 0x00, /* i */
  0x00, 0x06, 0x00, 0x06, 0x06, 0x06, 0x06, 0x3c, /* j */
  0x00, 0x60, 0x60, 0x6c, 0x78, 0x6c, 0x66, 0x00, /* k */
  0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, /* l */
  0x00, 0x00, 0x66, 0x7f, 0x7f, 0x6b, 0x63, 0x00, /* m */
  0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x00, /* n */
  0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00, /* o */
  0x00, 0x00, 0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60, /* p */
  0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x06, /* q */
  0x00, 0x00, 0x7c, 0x66, 0x60, 0x60, 0x60, 0x00, /* r */
  0x00, 0x00, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x00, /* s */
  0x00, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x0e, 0x00, /* t */
  0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x00, /* u */
  0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00, /* v */
  0x00, 0x00, 0x63, 0x6b, 0x7f, 0x3e, 0x36, 0x00, /* w */
  0x00, 0x00, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x00, /* x */
  0x00, 0x00, 0x66, 0x66, 0x66, 0x3e, 0x0c, 0x78, /* y */
  0x00, 0x00, 0x7e, 0x0c, 0x18, 0x30, 0x7e, 0x00, /* z */
  0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, /* { */
  0xc0, 0xc0, 0x30, 0x30, 0xc0, 0xc0, 0x30, 0x30, /* | */
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, /* } */
  0x00, 0x00, 0x03, 0x3e, 0x76, 0x36, 0x36, 0x00, /* ~ */
};

int abs (int j)
{
  if (j == 0) return 0;
  if (j > 0) return j;
  return -j;
}

static void
clear_screen (unsigned int color)
{
  int i;
  for (i = 0; i < WIDTH * HEIGHT; i++)
    pixels[i] = color;
}

static void
draw_pixel (int x, int y, unsigned int color)
{
  if (x < WIDTH && y < HEIGHT && x >= 0 && y >= 0)
    pixels[y * WIDTH + x] = color;
}

static void
draw_rect (int x, int y, int w, int h, unsigned int color)
{
  int i, j;

  for (i = x; i < x + w; i++) {
    for (j = y; j < y + h; j++) {
      draw_pixel (i, j, color);
    }
  }
}

static void
draw_icn (int x, int y, unsigned char *sprite, unsigned int color)
{
  int y2 = y + 8, h;

  for (; y < y2; y++, sprite++) {
    for (h = 0; h < 8; h++) {
      if (*sprite << h & 0x80)
        draw_pixel (x + h, y, color);
    }
  }
}

void
draw_letter (int x, int y, int letter, unsigned int fg_color, unsigned int bg_color)
{
  int idx = letter - 32;

  draw_rect (x, y, 8, 8, bg_color);
  draw_icn (x, y, font + (idx * 8), fg_color);
}

void
draw_string (int x, int y, char *string, unsigned int fg_color, unsigned int bg_color)
{
  int i;

  for (i = 0; i < (int)strlen (string); i++) {
    draw_letter (x + (i * 8), y, string[i], fg_color, bg_color);
  }
}

static void
set_window_size (SDL_Window *window, int w, int h)
{
  SDL_Point win_old;

  SDL_GetWindowSize (window, &win_old.x, &win_old.y);

  if (w == win_old.x && h == win_old.y) return;

  SDL_RenderClear (gRenderer);
  SDL_SetWindowSize (window, w, h);
}

static void
set_zoom (int z, int win)
{
  if (z < 1) return;

  if (win)
    set_window_size (gWindow, WIDTH * z, HEIGHT * z);

  zoom = z;
}

static void
emu_end (void)
{
    free (pixels);

    SDL_DestroyTexture (gTexture), gTexture = NULL;
    SDL_DestroyRenderer (gRenderer), gRenderer = NULL;
    SDL_DestroyWindow (gWindow), gWindow = NULL;

    SDL_Quit ();

    exit(0);
}

static int
init (void)
{
    if(SDL_Init(SDL_INIT_VIDEO) < 0)
      fprintf (stderr, "INIT ERROR: %s\n", SDL_GetError ());

    gWindow = SDL_CreateWindow (TITLE,
                                SDL_WINDOWPOS_UNDEFINED,
                                SDL_WINDOWPOS_UNDEFINED,
                                WIDTH, HEIGHT,
                                SDL_WINDOW_SHOWN);
    if (gWindow == NULL)
      fprintf (stderr, "WINDOW ERROR: %s\n", SDL_GetError ());

    gRenderer = SDL_CreateRenderer (gWindow, -1, 0);
    if (gRenderer == NULL)
      fprintf (stderr, "RENDERER ERROR: %s\n", SDL_GetError ());

    gTexture = SDL_CreateTexture(gRenderer,
                                 SDL_PIXELFORMAT_ARGB8888,
                                 SDL_TEXTUREACCESS_STATIC,
                                 WIDTH, HEIGHT);
    if (gTexture == NULL)
      fprintf (stderr, "TEXTURE ERROR: %s\n", SDL_GetError ());

    pixels = (unsigned int *)malloc (WIDTH * HEIGHT * sizeof (unsigned int));
    if (pixels == NULL)
      fprintf (stderr, "PIXELS ERROR: %s\n", "Failed to allocate memory");

    SDL_ShowCursor (1);

    return 1;
}

static int frame = 0;

static int cursor = 0;
static int selected;
static char *last_dir = "/home/fkinos/";

char **files;
static int files_counter = 0;

void
fetch_files (char *path)
{
  DIR *d;
  int i = 0;
  struct dirent *dir;

  files_counter = 0;

  d = opendir (path);
  if (d) {
    while ((dir = readdir (d)) != NULL) {
      if (dir->d_name[0] == '.') continue;
      files_counter++;
    }
  }

  files_counter++;

  files = malloc (files_counter * sizeof (char *));

  for (i = 0; i < files_counter; i++) {
    files[i] = (char *)malloc (256+1);
  }

  files[0] = "..";

  i = 1;

  d = opendir (path);
  if (d) {
    while ((dir = readdir(d)) != NULL) {
      if (dir->d_name[0] == '.')
        continue;

      files[i] = dir->d_name;

      i += 1;
    }

    closedir(d);
  }
}

char *
parent (char *filename)
{
  int i;
  int length;
  char *parent;

  length = strlen (filename);

  parent = (char *)malloc (length + 1);
  if (!parent) return NULL;

  strcpy (parent, filename);

  for (i = length; i > 0; i--) {
    if (filename[i] == '/')
      break;
  }

  parent[i] = '\0';

  if (strlen (parent) == 0)
    parent = "/";

  return parent;
}

void
setup ()
{
  clear_screen (BLACK);
}

int
is_directory (const char *path) {
   struct stat statbuf;

   if (stat (path, &statbuf) != 0)
       return 0;

   return S_ISDIR (statbuf.st_mode);
}

void
update ()
{
  if (frame <= 10)
    fetch_files (last_dir);

  frame += 1;
}

void
on_keydown (SDL_Event e)
{
  int i;
  int sym = e.key.keysym.sym;
  SDL_Keymod mods = e.key.keysym.mod;
  int alt = 0;
  int shift = 0;
  int ctrl = 0;

  if (mods & KMOD_ALT) alt = 1;
  if (mods & KMOD_SHIFT) shift = 1;
  if (mods & KMOD_CTRL) ctrl = 1;

  char *test;

  switch (sym) {
  case SDLK_UP: cursor -= 1; break;
  case SDLK_DOWN: cursor += 1; break;
  case SDLK_RETURN:
    selected = cursor;

    test = (char *)malloc (strlen (last_dir) + strlen (files[selected]) + 1);

    if (strcmp (files[selected], "..") == 0) {
      test = parent (last_dir);
      last_dir = test;
      fetch_files (last_dir);

      break;
    }

    strcpy (test, last_dir);

    if (test[strlen (test) - 1] != '/')
      strcat (test, "/");

    strcat (test, files[selected]);

    if (!is_directory (test))
      break;

    last_dir = test;

    cursor = 0;

    fetch_files (last_dir);

    break;
  }

  if (cursor < 0) cursor = 0;
  if (cursor > files_counter - 1) cursor = files_counter - 1;
}

void
draw ()
{
  int i;

  clear_screen (BLACK);

  draw_string (0, 0, "NAME", WHITE, BLACK);

  for (i = 0; i < files_counter; i++) {
    draw_string ((i == cursor) ? 8 : 0, i * 8 + 16, files[i], WHITE, BLACK);
  }

  draw_string (0, HEIGHT - 8, last_dir, WHITE, BLACK);
}

int
main (int argc, char *argv[])
{
  Uint32 begintime = 0, endtime = 0, delta = 0;

  if (!init ())
    fprintf (stderr, "INIT ERROR: FAILURE\n");
  set_zoom (1, 1);

  setup ();

  /* Game Loop */
  while (1) {
    SDL_Event e;

    /* don't draw if not needed */
    if (!begintime) {
      begintime = SDL_GetTicks ();
    } else {
      delta = endtime - begintime;
    }

    if (delta < 30)
      SDL_Delay (30 - delta);

    /* gather events from the user and the operation system */
    while (SDL_PollEvent (&e) != 0) {
      switch(e.type) {
      case SDL_QUIT: emu_end (); break;
      case SDL_WINDOWEVENT: reqdraw = 1; break;
      case SDL_KEYDOWN: on_keydown (e); break;
      }
    }

    update ();
    if (reqdraw)
      draw ();

    /* draw pixels array to SDL texture */
    SDL_UpdateTexture (gTexture, NULL, pixels, WIDTH * sizeof (unsigned int));
    SDL_RenderCopy (gRenderer, gTexture, NULL, NULL);
    SDL_RenderPresent (gRenderer);

    begintime = endtime;
    endtime = SDL_GetTicks ();
  }

  emu_end();

  return 0;
}
